package test;

import java.util.Arrays;

public class SecondTask {
	/*
	 * Input
	 * 
	 * s [the number of tests <= 10] n [the number of cities <= 10000] NAME
	 * [city name] p [the number of neighbours of city NAME] nr cost [nr - index
	 * of a city connected to NAME (the index of the first city is 1)] [cost -
	 * the transportation cost] r [the number of paths to find <= 100] NAME1
	 * NAME2 [NAME1 - source, NAME2 - destination] [empty line separating the
	 * tests]
	 * 
	 * Output
	 * 
	 * cost [the minimum transportation cost from city NAME1 to city NAME2 (one
	 * per line)]
	 * 
	 * Example
	 * 
	 * Input: 1 4 gdansk 2 2 1 3 3 bydgoszcz 3 1 1 3 1 4 4 torun 3 1 3 2 1 4 1
	 * warszawa 2 2 4 3 1 2 gdansk warszawa bydgoszcz warszawa
	 * 
	 * Output: 3 2
	 */
	

	int INF = Integer.MAX_VALUE / 2; // "Бесконечность"
	int vNum = 4; // количество вершин
	int[][] graph = new int[vNum][vNum]; // матрица смежности
	//graph[0][0] = INF;
	//graph[0][0] = INF;

	public void dijkstra(int start) {
		boolean[] used = new boolean[vNum]; // массив пометок
		int[] dist = new int[vNum]; // массив расстояния. dist[v] =
									// минимальное_расстояние(start, v)
		Arrays.fill(dist, INF); // устанаавливаем расстояние до всех вершин INF
		dist[start] = 0; // для начальной вершины положим 0
		for (;;) {
			int v = -1;
			for (int nv = 0; nv < vNum; nv++){ // перебираем вершины
				if (!used[nv] && dist[nv] < INF && (v == -1 || dist[v] > dist[nv])){ // выбираем самую близкую непомеченную вершину
					v = nv;
				}
			}
			if (v == -1){
				break; // ближайшая вершина не найдена
			}
			used[v] = true; // помечаем ее
			for (int nv = 0; nv < vNum; nv++)
				if (!used[nv] && graph[v][nv] < INF) // для всех непомеченных смежных
					dist[nv] = Math.min(dist[nv], dist[v] + graph[v][nv]); // улучшаем оценку расстояния (релаксация)
		}
	}

	public static void main(String[] args) {

	}

}
