package test;

public class SecondTask {
	/*
	 * Input
	 * 
	 * s [the number of tests <= 10] n [the number of cities <= 10000] NAME
	 * [city name] p [the number of neighbours of city NAME] nr cost [nr - index
	 * of a city connected to NAME (the index of the first city is 1)] [cost -
	 * the transportation cost] r [the number of paths to find <= 100] NAME1
	 * NAME2 [NAME1 - source, NAME2 - destination] [empty line separating the
	 * tests]
	 * 
	 * Output
	 * 
	 * cost [the minimum transportation cost from city NAME1 to city NAME2 (one
	 * per line)]
	 * 
	 * Example
	 * 
	 * Input: 1 4 gdansk 2 2 1 3 3 bydgoszcz 3 1 1 3 1 4 4 torun 3 1 3 2 1 4 1
	 * warszawa 2 2 4 3 1 2 gdansk warszawa bydgoszcz warszawa
	 * 
	 * Output: 3 2
	 */
	

	int INF = Integer.MAX_VALUE / 2; // "Ѕесконечность"
	int vNum; // количество вершин
	int[][] graph; // матрица смежности

	/* јлгоритм ƒейкстры за O(V^2) */
	void dijkstra(int start) {
		boolean[] used = new boolean[vNum]; // массив пометок
		int[] dist = new int[vNum]; // массив рассто€ни€. dist[v] =
									// минимальное_рассто€ние(start, v)
		Arrays.fill(dist, INF); // устанаавливаем рассто€ние до всех вершин INF
		dist[start] = 0; // дл€ начальной вершины положим 0
		for (;;) {
			int v = -1;
			for (int nv = 0; nv < vNum; nv++){ // перебираем вершины
				if (!used[nv] && dist[nv] < INF && (v == -1 || dist[v] > dist[nv])){ // выбираем самую близкую непомеченную вершину
					v = nv;
				}
			}
			if (v == -1){
				break; // ближайша€ вершина не найдена
			}
			used[v] = true; // помечаем ее
			for (int nv = 0; nv < vNum; nv++)
				if (!used[nv] && graph[v][nv] < INF) // дл€ всех непомеченных
														// смежных
					dist[nv] = Math.min(dist[nv], dist[v] + graph[v][nv]); // улучшаем оценку рассто€ни€ (релаксаци€)
		}
	}
	public void fill(int[] dist, int n) {
		
	}

	public static void main(String[] args) {

	}

}
